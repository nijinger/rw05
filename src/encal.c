#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <math.h>
#include <string.h>

#include "util.h"

int main(int argc, char **argv)
{
  double a[6], x[50], dx[50], y[50], dy[50], x1[50], y1[50], sigma[50];
  double d1, d2, diff, a1, a2, chisqr, fit, resid;
  int    mode = 1;
  int    npts, i, j, j1, j2, nc, iorder, nterms;
  char   nf[80], title[120], line[120], ans[80];
  char   outfil[80] = "encal.out";
  FILE  *file1, *file2;
  
  int polfit(double *, double *, double *,
	     int, int, int, double *, double *);

  /* ENCAL  -  a program to fit energies to channel numbers
     for energy calibrations */
  printf(" \n\n"
     " WELCOME TO ENCAL.\n\n"
     " This program does polynomial fits to energy calibrations.\n"
     " It takes its input data from .sin files, which may be\n"
     "   generated by running the program Source.\n"
     " You may choose any order of polynomial from one (i.e. linear)\n"
     "   to five. When you have a satisfactory fit, you may store\n"
     "   the parameters in a disk (.aca) file, which may then be\n"
     "   used to input the calibration to such programs as gf3\n"
     "   and energy.\n\n"
     " C version    D. C. Radford    Nov. 1999.\n");

  /* open output (print) file */
  file2 = open_new_file(outfil, 1);

  /* ask for data file name */
  while (1) {
    if (argc > 1) {
      strncpy(nf, argv[1], 70);
      argc = 0;
    } else {
      cask("Input data file = ? (default .EXT = .sin)", nf, 80);
    }
    setext(nf, ".sin", 80);
    if (!(file1 = open_readonly(nf))) continue;
    if (!fgets(title, 120, file1)) goto NEXTFIL;

    for (i = 0; i < 50; ++i) {
      if (!fgets(line, 120, file1) ||
	  sscanf(line, "%*d%lf%lf%*f%*f%lf%lf",
		 &x[i], &dx[i], &y[i], &dy[i]) != 4) goto ATEOF;
      if (x[i] == 0.0) i--;
      if (x[i] == -99.0) goto ATEOF;
    }
    i = 50;
    printf("First 50 data points only taken.\n");
  ATEOF:
    fclose(file1);
    npts = i;
    if (npts < 3) {
      printf("Too few data points.\n");
      goto NEXTFIL;
    }

    polfit(x, y, dy, npts, 2, 0, a, &chisqr);
    a1 = a[0];
    a2 = a[1];
    for (i = 0; i < npts; ++i) {
      x1[i] = x[i] / 1e3f;
      y1[i] = y[i] - a1 - a2 * x[i];
      d1 = dy[i];
      d2 = dx[i] * a2;
      sigma[i] = sqrt(d1 * d1 + d2 * d2);
      if (sigma[i] == 0.) {
	printf("Errors must be nonzero; zero value set to 1.0 chs.\n");
	sigma[i] = 1.f;
      }
    }

    while ((nc = cask("Order of polynomial to be fitted = ?\n"
		      "             (1 thru 5, or 0 to end)", ans, 80))) {
      if (inin(ans, nc, &iorder, &j1, &j2)) continue;  
      if (iorder <= 0) break;
      if (iorder > 5) iorder = 5;
      if (iorder + 2 > npts) {
	printf("Sorry, too few data points for that order.\n");
	continue;
      }
      nterms = iorder + 1;
      for (i = 0; i < 6; ++i) {
	a[i] = 0.0;
      }
      polfit(x1, y1, sigma, npts, nterms, mode, a, &chisqr);
      for (i = 1; i < nterms; ++i) {
	for (j = i; j < nterms; ++j) {
	  a[j] /= 1e3f;
	}
      }

      a[0] += a1;
      a[1] += a2;
      printf("%s\n Order = %i\n"
	     "    Channel +- Error     Energy +- Error"
	     "       Fit     Difference   Residual\n",
	     title, iorder);
      fprintf(file2, "\f%s\n Order = %i\n"
	      "    Channel +- Error     Energy +- Error"
	      "       Fit     Difference   Residual\n",
	      title, iorder);
      for (i = 0; i < npts; ++i) {
	fit = a[nterms - 1];
	for (j = iorder-1; j >= 0; --j) {
	  fit = a[j] + fit * x[i];
	}
	diff = fit - y[i];
	resid = diff / sigma[i];
	printf("%11.3f %8.3f %10.3f %8.3f %11.3f %11.3f %11.3f\n",
	       x[i], dx[i], y[i], dy[i], fit, diff, resid);
	fprintf(file2, "%11.3f %8.3f %10.3f %8.3f %11.3f %11.3f %11.3f\n",
		x[i], dx[i], y[i], dy[i], fit, diff, resid);
      }
      printf("\n Parameters =");
      fprintf(file2, "\n Parameters =");
      for (i = 0; i < nterms; ++i) {
	printf(" %13.5e", a[i]);
	fprintf(file2, " %13.5e", a[i]);
	if (i == 3 && nterms > 4) {
	  printf("\n            ");
	  fprintf(file2, "\n            ");
	}
      }
      printf("\n Chisqr/D.O.F. = %.3f\n", chisqr);
      fprintf(file2, "\n Chisqr/D.O.F. = %.3f\n", chisqr);

      if (caskyn("Do you want to write these values to a file? (Y/N)")) {
	/* ask for output file name */
	cask("Output file name = ? (default .ext = .aca)", nf, 80);
	setext(nf, ".aca", 80);
	if ((file1 = open_new_file(nf, 0))) {
	  fprintf(file1, "  ENCAL OUTPUT FILE\n%s", title);
	  fprintf(file1, "%5d %18.11E %18.11E %18.11E\n"
		  "      %18.11E %18.11E %18.11E\n", iorder,
		  a[0], a[1], a[2], a[3], a[4], a[5]);
	  fclose(file1);
	  printf("   ...File %s created.\n", nf);
	}
      }
    }
    NEXTFIL:
    if (!caskyn("Would you like to process more files? (Y/N)")) break;
  }
  fclose(file2);
  pr_and_del_file(outfil);
  return 0;
} /* encal */

/* ====================================================================== */
int polfit(double *x, double *y, double *sigmay, int npts,
	   int nterms, int mode, double *a, double *chisqr)
{
  double weight, sumx[19], sumy[10];
  double delta, chisq, array[10][10];
  double xterm, yterm, xi, yi;
  int    nmax, i, j, k, l, n;

  double determ(double *, int);

  /* accumulate weighted sums */
  nmax = 2*nterms - 1;
  for (n = 0; n < nmax; ++n) {
    sumx[n] = 0.;
  }
  for (j = 0; j < nterms; ++j) {
    sumy[j] = 0.;
  }
  chisq = 0.;
  for (i = 0; i < npts; ++i) {
    xi = x[i];
    yi = y[i];
    if (mode < 0) {
      if (yi > 0.f) {
	weight = 1.f / yi;
      } else if (yi < 0.f) {
	weight = 1.f / (-yi);
      } else {
	weight = 1.f;
      }
    } else if (mode == 0) {
      weight = 1.f;
    } else {
      weight = 1.f / (sigmay[i] * sigmay[i]);
    }
    xterm = weight;
    for (n = 0; n < nmax; ++n) {
      sumx[n] += xterm;
      xterm *= xi;
    }
    yterm = weight * yi;
    for (n = 0; n < nterms; ++n) {
      sumy[n] += yterm;
      yterm *= xi;
    }
    chisq += weight * yi * yi;
  }
  /* construct matrices and calculate coefficients */
  for (j = 0; j < nterms; ++j) {
    for (k = 0; k < nterms; ++k) {
      n = j + k;
      array[k][j] = sumx[n];
    }
  }
  delta = determ(array[0], nterms);
  if (delta == 0.f) {
    *chisqr = 0.f;
    for (j = 0; j < nterms; ++j) {
      a[j] = 0.f;
    }
  } else {
    for (l = 0; l < nterms; ++l) {
      for (j = 0; j < nterms; ++j) {
	for (k = 0; k < nterms; ++k) {
	  n = j + k;
	  array[k][j] = sumx[n];
	}
	array[l][j] = sumy[j];
      }
      a[l] = determ(array[0], nterms) / delta;
    }
    /* calculate chi square */
    for (j = 0; j < nterms; ++j) {
      chisq -= a[j] * 2.f * sumy[j];
      for (k = 0; k < nterms; ++k) {
	n = j + k;
	chisq += a[j] * a[k] * sumx[n];
      }
    }
    *chisqr = chisq / (npts - nterms);
  }
  return 0;
} /* polfit */

/* ====================================================================== */
double determ(double *array, int norder)
{
  double save, ret_val;
  int    i, j, k;

  ret_val = 1.f;
  for (k = 0; k < norder; ++k) {
    /* interchange columns if diagonal element is zero */
    if (array[k + k*10] == 0.f) {
      for (j = k; j < norder; ++j) {
	if (array[k + j*10] != 0.f) break;;
      }
      if (j >= norder) return 0.f;
      for (i = k; i < norder; ++i) {
	save = array[i + j*10];
	array[i + j*10] = array[i + k*10];
	array[i + k*10] = save;
      }
      ret_val = -ret_val;
    }
    /* subtract row k from lower rows to get diagonal matrix */
    ret_val *= array[k + k*10];
    for (i = k+1; i < norder; ++i) {
      for (j = k+1; j < norder; ++j) {
	array[i + j*10] -= array[i + k*10] * array[k + j*10] / array[k + k*10];
      }
    }
  }
  return ret_val;
} /* determ */
